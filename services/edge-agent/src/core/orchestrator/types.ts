/**
 * FSM Types - State Machine Type Definitions
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * PURPOSE
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Defines TypeScript types for the FSM (Finite State Machine) architecture:
 *
 * 1. State: Valid FSM states (IDLE, DWELL, ACTIVE, CLOSING)
 * 2. Command: Side effects the FSM can generate (StartStream, OpenSession, etc.)
 * 3. FSMContext: Persistent context across state transitions
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * WHY EXPLICIT TYPES?
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Benefits of strong typing:
 *
 * 1. Type Safety
 *    - Compiler validates only valid states/commands are used
 *    - Catches typos at compile-time (e.g., "ACTIV" → error)
 *    - Prevents invalid state transitions (type checking)
 *
 * 2. IDE Support
 *    - Autocomplete suggests valid states/commands
 *    - Jump to definition shows type details
 *    - Refactoring tools work correctly
 *
 * 3. Self-Documenting
 *    - Types serve as executable documentation
 *    - Union types show all possible values
 *    - Comments explain purpose and usage
 *
 * 4. Refactoring Safety
 *    - Rename state → Compiler finds all usages
 *    - Add new command → TypeScript shows where to handle it
 *    - Delete state → Error if still referenced
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * STATE TYPE
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Recording lifecycle state machine:
 *
 * ```
 * IDLE (No activity)
 *   ↓ [ai.detection relevant=true]
 * DWELL (Confirming presence)
 *   ↓ [fsm.t.dwell.ok after dwellMs]
 * ACTIVE (Recording session)
 *   ↓ [fsm.t.silence.ok after silenceMs]
 * CLOSING (Post-roll recording)
 *   ↓ [fsm.t.postroll.ok after postRollMs]
 * IDLE (Session closed)
 * ```
 *
 * Re-activation during CLOSING:
 * ```
 * CLOSING
 *   ↓ [ai.detection relevant=true before postroll expires]
 * ACTIVE (Resume recording, extend session)
 * ```
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * SESSION ID INVARIANTS
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Session ID lifecycle (stored in FSMContext):
 *
 * State      | sessionId Value     | Session Status
 * -----------|---------------------|------------------------------------
 * IDLE       | undefined           | No session (idle)
 * DWELL      | undefined           | Session not yet opened (confirming)
 * ACTIVE     | "sess_cam-01_..."   | Session active (recording)
 * CLOSING    | "sess_cam-01_..."   | Session closing (post-roll)
 * IDLE       | undefined           | Session closed (back to idle)
 *
 * Session lifecycle flow:
 *
 * 1. IDLE → DWELL (detection received)
 *    - sessionId: undefined (no session yet)
 *
 * 2. DWELL → ACTIVE (dwell timer expires)
 *    - Command: OpenSession
 *    - sessionId: still undefined (waiting for response)
 *
 * 3. Async: Session Store responds
 *    - Event: session.open { sessionId: "sess_cam-01_1234567890_1" }
 *    - sessionId: set to "sess_cam-01_1234567890_1"
 *
 * 4. ACTIVE → CLOSING (silence timer expires)
 *    - sessionId: still "sess_cam-01_1234567890_1" (session active)
 *
 * 5. CLOSING → IDLE (post-roll timer expires)
 *    - Command: CloseSession { sessionId: "sess_cam-01_1234567890_1" }
 *    - sessionId: cleared to undefined (session closed)
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * COMMAND TYPE
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Commands are declarative side effects generated by the FSM reducer.
 * They specify WHAT to do, not HOW to do it.
 *
 * Execution model:
 * - FSM reducer generates commands (pure function)
 * - Orchestrator executes commands (side effects)
 * - Commands may trigger async operations (HTTP, process spawn)
 * - Async results return as events (e.g., session.open)
 *
 * Available commands:
 *
 * 1. StartStream
 *    - Purpose: Start RTSP publisher (SHM → MediaMTX)
 *    - Triggered: DWELL → ACTIVE transition
 *    - Effect: Spawns MediaMtxOnDemandPublisherGst process
 *
 * 2. StopStream
 *    - Purpose: Stop RTSP publisher (release resources)
 *    - Triggered: ACTIVE/CLOSING → IDLE transition
 *    - Effect: Kills publisher process, closes RTSP connection
 *    - Optional reason: Logs why stream stopped (e.g., "session closed")
 *
 * 3. OpenSession
 *    - Purpose: Create new session in Session Store
 *    - Triggered: DWELL → ACTIVE transition
 *    - Effect: HTTP POST /sessions/open → Returns sessionId
 *    - Async: Emits session.open event when complete
 *    - Optional timestamp: Custom startTs (default: Date.now())
 *
 * 4. CloseSession
 *    - Purpose: Close active session with end timestamp
 *    - Triggered: CLOSING → IDLE transition
 *    - Effect: HTTP POST /sessions/close → Marks session ended
 *    - Required: sessionId (must exist in context)
 *    - Optional timestamp: Custom endTs (default: Date.now())
 *
 * 5. SetAIFpsMode
 *    - Purpose: Adjust AI capture rate (idle vs active)
 *    - Triggered: State changes affecting capture needs
 *    - Effect: Sets window FPS in AIFeeder
 *    - Modes:
 *      * "idle": Low FPS (e.g., 1 fps for detection)
 *      * "active": High FPS (e.g., 5 fps for recording)
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * DETECTION INGESTION
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Note: Detection upload is handled automatically by FrameIngester, not commands.
 *
 * Flow:
 * - AI Engine produces detections → ai.detection event
 * - FrameIngester subscribes to ai.detection
 * - FrameIngester uploads frame + detections via HTTP POST /ingest
 * - No FSM command needed (handled by event subscription)
 *
 * Why not a command?
 * - Detections arrive at high frequency (5-10 fps during active session)
 * - Command execution would create tight coupling (FSM → FrameIngester)
 * - Event subscription is cleaner (loose coupling, better performance)
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * FSM CONTEXT TYPE
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Persistent context across FSM transitions.
 * Immutable: Each transition creates new context object.
 *
 * Fields:
 *
 * - state: Current FSM state (IDLE | DWELL | ACTIVE | CLOSING)
 * - sessionId: Active session ID (undefined if no session)
 *
 * Why sessionId in context?
 *
 * - OpenSession is async (HTTP POST to Session Store)
 * - Session Store returns sessionId in session.open event
 * - Need to store sessionId to use in later CloseSession command
 * - Context provides persistent storage across state transitions
 *
 * Immutability pattern:
 *
 * ```typescript
 * // FSM reducer creates new context on each transition
 * function reduce(ctx: FSMContext, event: Event): { newCtx: FSMContext, commands: Command[] } {
 *   // Bad: Mutating context (breaks pure function)
 *   // ctx.state = "ACTIVE"; // ❌ NO!
 *
 *   // Good: Creating new context (pure function)
 *   const newCtx = { ...ctx, state: "ACTIVE" }; // ✅ YES!
 *   return { newCtx, commands: [...] };
 * }
 * ```
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * USAGE EXAMPLES
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * ```typescript
 * import type { State, Command, FSMContext } from "./types.js";
 *
 * // Example 1: FSM Reducer (generates commands)
 * function reduce(ctx: FSMContext, event: AllEvents): {
 *   newCtx: FSMContext;
 *   commands: Command[];
 * } {
 *   if (ctx.state === "DWELL" && event.type === "fsm.t.dwell.ok") {
 *     return {
 *       newCtx: { ...ctx, state: "ACTIVE" },
 *       commands: [
 *         { type: "StartStream" },
 *         { type: "OpenSession" },
 *         { type: "SetAIFpsMode", mode: "active" },
 *       ],
 *     };
 *   }
 *   // ... more transitions
 * }
 *
 * // Example 2: Orchestrator (executes commands)
 * async function executeCommand(cmd: Command): Promise<void> {
 *   switch (cmd.type) {
 *     case "StartStream":
 *       await publisher.start();
 *       break;
 *     case "OpenSession":
 *       const sessionId = await store.openSession(cmd.at);
 *       bus.publish("session.open", { sessionId });
 *       break;
 *     case "CloseSession":
 *       await store.closeSession(cmd.sessionId, cmd.at);
 *       break;
 *     // ... more command handlers
 *   }
 * }
 *
 * // Example 3: Context Update (storing sessionId)
 * if (event.type === "session.open") {
 *   ctx = { ...ctx, sessionId: event.sessionId };
 * }
 * ```
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * INTEGRATION POINTS
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * Used by:
 * - fsm.ts: FSM reducer uses State, Command, FSMContext
 * - orchestrator.ts: Command executor uses Command type
 * - timers.ts: Timer manager uses State type
 *
 * Dependencies:
 * - None (pure type definitions, no runtime dependencies)
 *
 * @module core/orchestrator/types
 */

/**
 * FSM State - Valid states for the recording lifecycle state machine
 *
 * State transition diagram:
 *
 * ```
 * IDLE → DWELL → ACTIVE → CLOSING → IDLE
 *                   ↑         │
 *                   └─────────┘  (re-activation)
 * ```
 *
 * State descriptions:
 *
 * - IDLE: No activity, waiting for detections
 *   - sessionId: undefined
 *   - Stream: Stopped
 *   - AI FPS: Low (idle mode)
 *
 * - DWELL: Confirming sustained presence
 *   - sessionId: undefined (session not yet opened)
 *   - Stream: Starting
 *   - AI FPS: Transitioning to active mode
 *   - Timer: DWELL (fixed, ~2 seconds)
 *
 * - ACTIVE: Recording active session
 *   - sessionId: "sess_cam-01_..." (set after session.open)
 *   - Stream: Running
 *   - AI FPS: High (active mode)
 *   - Timer: SILENCE (resetable, ~5 seconds)
 *
 * - CLOSING: Post-roll recording (after last detection)
 *   - sessionId: "sess_cam-01_..." (still active)
 *   - Stream: Running
 *   - AI FPS: High (active mode)
 *   - Timer: POST-ROLL (fixed, ~3 seconds)
 */
export type State = "IDLE" | "DWELL" | "ACTIVE" | "CLOSING";

/**
 * FSM Command - Declarative side effects generated by FSM reducer
 *
 * Commands are pure data structures that specify WHAT to do (not HOW).
 * The Orchestrator executes commands as side effects.
 *
 * Command catalog:
 *
 * - StartStream: Start RTSP publisher (SHM → MediaMTX)
 * - StopStream: Stop RTSP publisher (release resources)
 * - OpenSession: Create new session in Session Store (async)
 * - CloseSession: Close active session with end timestamp
 * - SetAIFpsMode: Adjust AI capture rate (idle vs active)
 *
 * Note: Detection upload is NOT a command (handled by FrameIngester via events)
 *
 * @example
 * ```typescript
 * // FSM generates commands (pure function)
 * const commands: Command[] = [
 *   { type: "StartStream" },
 *   { type: "OpenSession" },
 *   { type: "SetAIFpsMode", mode: "active" },
 * ];
 *
 * // Orchestrator executes commands (side effects)
 * for (const cmd of commands) {
 *   await executeCommand(cmd);
 * }
 * ```
 */
export type Command =
  | { type: "StartStream" }
  | { type: "StopStream"; reason?: string }
  | { type: "OpenSession"; at?: string }
  | { type: "CloseSession"; sessionId: string; at?: string }
  | { type: "SetAIFpsMode"; mode: "idle" | "active" };

/**
 * FSM Context - Persistent context across state transitions
 *
 * Immutable context object that survives between FSM transitions.
 * Each transition creates a new context object (pure functional approach).
 *
 * Fields:
 *
 * - state: Current FSM state (IDLE | DWELL | ACTIVE | CLOSING)
 * - sessionId: Active session ID (undefined if no session)
 *
 * Why sessionId?
 *
 * - OpenSession is async (HTTP POST to Session Store)
 * - Session Store returns sessionId in session.open event
 * - Need to store sessionId to use in CloseSession command
 * - Context provides persistent storage across transitions
 *
 * Session ID lifecycle:
 *
 * ```
 * DWELL → ACTIVE:
 *   ctx.sessionId = undefined
 *   Command: OpenSession
 *       ↓ (async HTTP POST)
 *   Event: session.open { sessionId: "sess_cam-01_1234567890_1" }
 *       ↓
 *   ctx.sessionId = "sess_cam-01_1234567890_1"
 *       ↓
 *   AI Engine sends frames with sessionId via FrameIngester
 *       ↓
 * ACTIVE → CLOSING → IDLE:
 *   Command: CloseSession { sessionId: "sess_cam-01_1234567890_1" }
 *   ctx.sessionId = undefined (session closed)
 * ```
 *
 * @example
 * ```typescript
 * // Initial context
 * let ctx: FSMContext = { state: "IDLE", sessionId: undefined };
 *
 * // FSM transition creates new context (immutable)
 * const { newCtx, commands } = reduce(ctx, event);
 * ctx = newCtx; // Replace context
 *
 * // Example: Storing sessionId from async event
 * if (event.type === "session.open") {
 *   ctx = { ...ctx, sessionId: event.sessionId };
 * }
 * ```
 */
export interface FSMContext {
  state: State;
  sessionId?: string;
}
