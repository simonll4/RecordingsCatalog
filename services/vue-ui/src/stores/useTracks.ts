/**
 * Tracks Store (Refactored)
 * Manages track data, segments, and rendering
 * - Loads and caches session metadata and index
 * - Manages segment loading with LRU cache
 * - Provides filtered events for rendering
 * - Handles UI state for filters and visualization
 */

import { computed, ref } from 'vue'
import { defineStore } from 'pinia'
import { wrap } from 'comlink'
import { sessionService, HttpError } from '@/api'
import { segmentCache } from './segmentCache'
import { processBBox } from '@/utils'
import { SEGMENT_CONFIG, UI_CONFIG } from '@/constants'
import type { TrackEvent, TrackIndex, TrackMeta, RenderObject } from '../types/tracks'

/**
 * NDJSON Parser Worker Interface
 */
interface NdjsonParser {
  parseSegment(data: ArrayBuffer, encoding: string | null): Promise<TrackEvent[]>
}

// Initialize worker
const parserWorker = new Worker(
  new URL('../workers/ndjsonParser.worker.ts', import.meta.url),
  { type: 'module' }
)
const parser = wrap<NdjsonParser>(parserWorker)

/**
 * Tracks Store
 */
export const useTracksStore = defineStore('tracks', () => {
  // === State ===
  const meta = ref<TrackMeta | null>(null)
  const index = ref<TrackIndex | null>(null)
  const sessionId = ref<string | null>(null)
  
  // Segment management
  const segmentEvents = ref<Map<number, TrackEvent[]>>(new Map())
  const loadingSegments = ref<Set<number>>(new Set())
  const lru = ref<number[]>([])
  
  // Error states
  const error = ref<string | null>(null)
  const metaMissing = ref(false)
  const indexMissing = ref(false)
  
  // Temporal compensation (video start vs meta start_time)
  const overlayShiftSeconds = ref(0)
  
  // === UI State / Filters ===
  const confMin = ref<number>(UI_CONFIG.FILTERS.DEFAULT_CONFIDENCE_MIN)
  const showBoxes = ref<boolean>(UI_CONFIG.FILTERS.DEFAULT_SHOW_BOXES)
  const showLabels = ref<boolean>(UI_CONFIG.FILTERS.DEFAULT_SHOW_LABELS)
  const showTrails = ref<boolean>(UI_CONFIG.FILTERS.DEFAULT_SHOW_TRAILS)
  const selectedClasses = ref<Set<number>>(new Set())
  
  // === Computed ===
  const availableClasses = computed(() => meta.value?.classes ?? [])
  const hasSegments = computed(() => index.value !== null && !indexMissing.value)
  
  // === Internal Helpers ===
  
  /**
   * Mark a segment as loading or not
   */
  const markSegmentLoading = (segmentIndex: number, value: boolean) => {
    const next = new Set(loadingSegments.value)
    if (value) {
      next.add(segmentIndex)
    } else {
      next.delete(segmentIndex)
    }
    loadingSegments.value = next
  }
  
  /**
   * LRU: Touch segment (move to end of queue)
   * Evict old segments if over limit
   */
  const touchSegment = (segmentIndex: number) => {
    const filtered = lru.value.filter((idx) => idx !== segmentIndex)
    filtered.push(segmentIndex)
    lru.value = filtered
    
    if (filtered.length > SEGMENT_CONFIG.MAX_SEGMENTS_IN_MEMORY) {
      const overflow = filtered.length - SEGMENT_CONFIG.MAX_SEGMENTS_IN_MEMORY
      const currentMap = new Map(segmentEvents.value)
      
      for (let i = 0; i < overflow; i++) {
        const evicted = filtered.shift()
        if (evicted === undefined) break
        currentMap.delete(evicted)
      }
      
      lru.value = filtered
      segmentEvents.value = currentMap
    }
  }
  
  /**
   * Set events for a segment and update LRU
   */
  const setSegmentEvents = (segmentIndex: number, events: TrackEvent[]) => {
    const nextMap = new Map(segmentEvents.value)
    nextMap.set(segmentIndex, events)
    segmentEvents.value = nextMap
    touchSegment(segmentIndex)
  }
  
  /**
   * Filter an object based on confidence and selected classes
   */
  const filterObject = (obj: TrackEvent['objs'][number]): boolean => {
    if (obj.conf < confMin.value) {
      return false
    }
    if (selectedClasses.value.size > 0 && !selectedClasses.value.has(obj.cls)) {
      return false
    }
    return true
  }
  
  // === Public Actions ===
  
  /**
   * Reset store for a new session
   * Clears all data and cache for the session
   */
  const resetForSession = async (id: string) => {
    if (sessionId.value === id) {
      return
    }
    
    sessionId.value = id
    meta.value = null
    index.value = null
    segmentEvents.value = new Map()
    loadingSegments.value = new Set()
    lru.value = []
    error.value = null
    metaMissing.value = false
    indexMissing.value = false
    overlayShiftSeconds.value = 0
    selectedClasses.value = new Set()
    
    await segmentCache.clearSession(id)
  }
  
  /**
   * Load session metadata
   * Note: Meta is optional (generated by AI worker)
   * If not found, session will work without it
   */
  const loadMeta = async (id: string) => {
    try {
      const result = await sessionService.getTrackMeta(id)
      if (result) {
        meta.value = result
        metaMissing.value = false
      } else {
        meta.value = null
        metaMissing.value = true
      }
    } catch (err: unknown) {
      if (err instanceof HttpError && err.status === 404) {
        console.log('[useTracks] Meta.json not found (AI worker feature - optional)')
        meta.value = null
        metaMissing.value = true
      } else {
        console.error('Failed to load session meta', err)
        meta.value = null
        metaMissing.value = true
      }
    }
  }
  
  /**
   * Load session track index
   * Returns null if not found (404)
   */
  const loadIndex = async (id: string) => {
    try {
      const result = await sessionService.getTrackIndex(id)
      if (result) {
        index.value = result
        indexMissing.value = false
      } else {
        index.value = null
        indexMissing.value = true
      }
    } catch (err: unknown) {
      if (err instanceof HttpError && err.status === 404) {
        index.value = null
        indexMissing.value = true
        return
      }
      console.error('Failed to load session index', err)
      error.value = err instanceof Error ? err.message : 'Failed to load index'
      throw err
    }
  }
  
  /**
   * Ensure a segment is loaded in memory
   * - Checks memory cache first
   * - Then checks Dexie cache
   * - Finally fetches from server
   */
  const ensureSegment = async (id: string, segmentIndex: number) => {
    if (!index.value || indexMissing.value) return
    
    // Already in memory
    if (segmentEvents.value.has(segmentIndex)) {
      touchSegment(segmentIndex)
      return
    }
    
    // Already loading
    if (loadingSegments.value.has(segmentIndex)) {
      return
    }
    
    markSegmentLoading(segmentIndex, true)
    
    try {
      // Try cache first
      const cached = await segmentCache.get(id, segmentIndex)
      if (cached) {
        setSegmentEvents(segmentIndex, cached.events)
        return
      }
      
      // Fetch from server (segments are named like "seg-0000.jsonl", "seg-0001.jsonl", etc.)
      const segmentName = `seg-${String(segmentIndex).padStart(4, '0')}.jsonl`
      const blob = await sessionService.getTrackSegment(id, segmentName)
      const buffer = await blob.arrayBuffer()
      const events = await parser.parseSegment(buffer, null)
      setSegmentEvents(segmentIndex, events)
      
      // Save to cache
      const segmentInfo = index.value.segments.find((entry) => entry.i === segmentIndex)
      await segmentCache.put(id, segmentIndex, {
        events,
        closed: segmentInfo?.closed ?? false,
      })
    } catch (err: unknown) {
      if (err instanceof HttpError && err.status === 404) {
        // Segment not ready yet
        console.debug(`Segment ${segmentIndex} not ready yet`)
        return
      }
      console.error(`Failed to load segment ${segmentIndex}`, err)
      error.value = err instanceof Error ? err.message : 'Failed to load segment'
      throw err
    } finally {
      markSegmentLoading(segmentIndex, false)
    }
  }
  
  /**
   * Prefetch surrounding segments (non-blocking)
   */
  const prefetchAround = (segmentIndex: number) => {
    const currentId = sessionId.value
    if (!currentId || !hasSegments.value) return
    
    const idx = index.value
    const maxSegment = idx?.segments[idx.segments.length - 1]?.i ?? Number.POSITIVE_INFINITY
    const candidates = [segmentIndex - 1, segmentIndex + 1]
    
    for (const candidate of candidates) {
      if (candidate < 0 || candidate > maxSegment) continue
      void ensureSegment(currentId, candidate).catch((err) => {
        console.debug('Prefetch failure', err)
      })
    }
  }
  
  /**
   * Get segment index for a given time
   */
  const segmentIndexForTime = (time: number): number | null => {
    if (!index.value) return null
    const duration = index.value.segment_duration_s
    if (duration <= 0) return 0
    return Math.floor(time / duration)
  }
  
  /**
   * Get events at a specific time
   * Returns current objects and trails (if enabled)
   */
  const eventsAtTime = (
    time: number
  ): { current: RenderObject[]; trails: Map<number, RenderObject[]> } => {
    if (!index.value) {
      return { current: [], trails: new Map() }
    }
    
    // Apply temporal compensation
    const adjustedTime = time + overlayShiftSeconds.value
    const windowStart = Math.max(
      0,
      adjustedTime - (showTrails.value ? SEGMENT_CONFIG.TRAIL_WINDOW_SECONDS : SEGMENT_CONFIG.EVENT_WINDOW_SECONDS)
    )
    const windowEnd = adjustedTime + SEGMENT_CONFIG.EVENT_WINDOW_SECONDS
    const tolerance = SEGMENT_CONFIG.EVENT_WINDOW_SECONDS
    const trailWindow = showTrails.value ? SEGMENT_CONFIG.TRAIL_WINDOW_SECONDS : 0
    
    const results: RenderObject[] = []
    const trails = new Map<number, RenderObject[]>()
    
    const segDuration = index.value.segment_duration_s
    const minSegment = Math.max(0, Math.floor(windowStart / segDuration))
    const maxSegment = Math.floor(windowEnd / segDuration) + 1
    
    for (const [segmentIdx, events] of segmentEvents.value) {
      if (segmentIdx < minSegment || segmentIdx > maxSegment) {
        continue
      }
      
      for (const event of events) {
        const eventTime = event.t_rel_s
        if (eventTime < windowStart || eventTime > windowEnd) {
          continue
        }
        
        for (const obj of event.objs) {
          if (!filterObject(obj)) continue
          
          // Process bounding box
          const processedBBox = processBBox(
            obj.bbox_xyxy,
            meta.value?.video?.width,
            meta.value?.video?.height
          )
          
          if (!processedBBox) {
            // Log debug info for invalid boxes
            console.debug('Dropping invalid bbox', {
              sessionId: sessionId.value,
              segmentIdx,
              raw: obj.bbox_xyxy,
              videoWidth: meta.value?.video?.width,
              videoHeight: meta.value?.video?.height,
            })
            continue
          }
          
          const renderItem: RenderObject = {
            trackId: obj.track_id,
            cls: obj.cls,
            clsName: obj.cls_name,
            conf: obj.conf,
            bbox: processedBBox,
            time: eventTime,
          }
          
          // Add to current if within tolerance
          if (Math.abs(eventTime - adjustedTime) <= tolerance) {
            results.push(renderItem)
          }
          
          // Add to trails if within trail window
          if (
            trailWindow > 0 &&
            eventTime <= adjustedTime &&
            eventTime >= adjustedTime - trailWindow
          ) {
            const list = trails.get(renderItem.trackId) ?? []
            list.push(renderItem)
            trails.set(renderItem.trackId, list)
          }
        }
      }
    }
    
    // Sort trails by time (ascending) for proper rendering
    for (const [, list] of trails) {
      list.sort((a, b) => a.time - b.time)
    }
    
    return { current: results, trails }
  }
  
  /**
   * Toggle class filter
   */
  const toggleClass = (classId: number) => {
    const next = new Set(selectedClasses.value)
    if (next.has(classId)) {
      next.delete(classId)
    } else {
      next.add(classId)
    }
    selectedClasses.value = next
  }
  
  /**
   * Set overlay temporal shift
   */
  const setOverlayShift = (shiftSeconds: number) => {
    overlayShiftSeconds.value = shiftSeconds
  }
  
  /**
   * Reset all filters to defaults
   */
  const resetFilters = () => {
    confMin.value = UI_CONFIG.FILTERS.DEFAULT_CONFIDENCE_MIN
    showBoxes.value = UI_CONFIG.FILTERS.DEFAULT_SHOW_BOXES
    showLabels.value = UI_CONFIG.FILTERS.DEFAULT_SHOW_LABELS
    showTrails.value = UI_CONFIG.FILTERS.DEFAULT_SHOW_TRAILS
    selectedClasses.value = new Set()
  }
  
  return {
    // === State ===
    meta,
    index,
    sessionId,
    segmentEvents,
    loadingSegments,
    error,
    metaMissing,
    indexMissing,
    overlayShiftSeconds,
    
    // === UI State ===
    confMin,
    showBoxes,
    showLabels,
    showTrails,
    selectedClasses,
    
    // === Computed ===
    availableClasses,
    hasSegments,
    
    // === Actions ===
    resetForSession,
    loadMeta,
    loadIndex,
    ensureSegment,
    prefetchAround,
    eventsAtTime,
    segmentIndexForTime,
    toggleClass,
    setOverlayShift,
    resetFilters,
  }
})
